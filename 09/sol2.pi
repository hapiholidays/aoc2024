#include <sys/args.pi>
#include <sys/file.pi>
#include <struct/list.pi>
#include <struct/set.pi>
#include <console.pi>
#include <convert.pi>
#include "listutils.pi"
#include "strutils.pi"

#define ispure pure
#define debug(msg) c_dbg=new console(2 of 2); c_dbg[1]<<^str<<msg<<^nl<<^end

#define $nlist \
  2->1:Int; \
  2->1:Int; \
  $list(Int)
global $nlist nlist(1 pure,2);
local pure service Service(nlist (1 of 2) this) // {{{
( this[2]>>x>>n;
  if n<=0
  then res=new list(2 of 2);
       res<<Int;
       res[1]<<^takeover<<this;
  else res=new nlist(2 of 2);
       res[1]<<x<<n-1<<^cons<<x;
       res[1]<<^takeover<<this;
) // }}}
|
#define $parsediskmap \
  2->1:Int; \
  2->1:String; \
  $list(Int)
global $parsediskmap parsediskmap(1 ispure,2);
local ispure service Service(parsediskmap (1 of 2) this) // {{{
( this[2]>>fid>>data;
  if data&^length<=0
  then res=new list(2 of 2);
       res<<Int;
       res[1]<<^takeover<<this;
  else if data&^length<=1
  then Int size=0;
       STRING2INT(data,size) pure;
       res=new nlist(2 of 2);
       res[1]<<fid<<size<<^takeover<<this;
  else String sizestr=data/1;
       String data2=data%1;
       String freestr=data2/1;
       String data3=data2%1;
       res3=new parsediskmap(2 of 2);
       res3[1]<<fid+1<<data3;
       Int size=0;
       STRING2INT(sizestr,size) pure;
       Int free=0;
       STRING2INT(freestr,free) pure;
       res2=new nlist(2 of 2);
       res2[1]<<0-1<<free;
       res=new nlist(2 of 2);
       res[1]<<fid<<size;
       res[1]<<^append<<res2;
       res[1]<<^append<<res3;
       res[1]<<^takeover<<this;
) // }}}
|
#define $popfile \
  2->1:$list(Int)(2 of 1 pure,2); /* diskmap */\
  1->2:Int;                       /* file id */\
  1->2:Int;                       /* file length */\
  1->2:$list(Int)(2 of 1 pure,2); /* diskmap after file */\
  $list(Int)                      /* diskmap before file */
global $popfile popfile(1 ispure,2);
local ispure service Service(popfile (1 of 2) this) // {{{
( this[2]>>data;
  data[1]<<^pop;
  data[1]>>
  {^nil:
    this[2]<<0-1<<0-1;
    res1=new list(2 of 2);
    res1<<Int;
    this[2]<<res1;
    res2=new list(2 of 2);
    res2<<Int;
    res2[1]<<^takeover<<this;
   ^cons:
    data[1]>>head>>tail;
    restail=new popfile(2 of 2);
    restail[1]<<tail;
    restail[1]>>v>>l>>rest;
    if v=0-1
    then if head=0-1
         then rest[1]<<^cons<<head;
              this[2]<<0-1<<0-1<<rest;
              restail[1]<<^takeover<<this;
         else this[2]<<head<<1<<rest;
              restail[1]<<^takeover<<this;
    else if head=v
         then this[2]<<v<<l+1<<rest;
              restail[1]<<^takeover<<this;
         else this[2]<<v<<l<<rest;
              restail[1]<<^cons<<head<<^takeover<<this;
  }
) // }}}
|
#define $testfreeres \
  1->2:$list(Int)(2 of 1 pure,2); /* diskmap */\
  1->2:Bool; /* room here */\
  $end;
#define $testfree \
  2->1:$list(Int)(2 of 1 pure,2); /* diskmap */\
  2->1:Int; /* file id */\
  $testfreeres
global $testfree testfree(1 ispure,2);
local ispure service Service(insfile (1 of 2) this) // {{{
( this[2]>>data>>size;
  local Test($testfreeres(1 of 1 ispure,2) this, $list(Int)(2 of 1 pure,2) data, Int pos) // {{{
  ( if size<=pos
    then this[2]<<data<<True;
    else data[1]<<^get<<pos;
         data[1]>>
         {^err:
           data[1]>>err;
           this[2]<<data<<False;
          ^val:
           data[1]>>val;
           if 0<=val
           then this[2]<<data<<False;
           else Test(this,data,pos+1);
         }
  ) // }}}
  Test(this,data,0);
) // }}}
|
#define $insfileres \
  1->2 \
  {^err: \
    $list(Int)(2 of 1 pure,2); /* diskmap */\
   ^ok: \
    $list(Int)(2 of 1 pure,2); /* updated diskmap */\
  }
#define $insfile \
  2->1:$list(Int)(2 of 1 pure,2); /* diskmap */\
  2->1:Int; /* file id */\
  2->1:Int; /* file length */\
  $insfileres
global $insfile insfile(1 ispure,2);
local ispure service Service(insfile (1 of 2) this) // {{{
( this[2]>>data>>id>>len;
  tf=new testfree(2 of 2);
  tf[1]<<data<<len;
  tf[1]>>data>>free;
  if free
  then sl=new splitlist(2 of 2);
       sl<<Int;
       sl[1]<<data<<len;
       sl[1]>>junk;
       junk[1]<<^end;
       file=new nlist(2 of 2);
       file[1]<<id<<len;
       file[1]<<^append<<sl;
       this[2]<<^ok;
       file[1]<<^takeover<<this;
  else data[1]<<^pop;
       data[1]>>
       {^nil:
         this[2]<<^err;
         res=new list(2 of 2);
         res<<Int;
         res[1]<<^takeover<<this;
        ^cons:
         data[1]>>head>>tail;
         inf=new insfile(2 of 2);
         inf[1]<<tail<<id<<len;
         inf[1]>>
         {^err:
           inf[1]<<^cons<<head;
           this[2]<<^err;
           inf[1]<<^takeover<<this;
          ^ok:
           inf[1]<<^cons<<head;
           this[2]<<^ok;
           inf[1]<<^takeover<<this;
         }
       }
) // }}}
|
#define $compressdiskmap \
  2->1:$list(Int)(2 of 1 pure,2); \
  $list(Int)
global $compressdiskmap compressdiskmap(1 ispure,2);
local ispure service Service(compressdiskmap (1 of 2) this) // {{{
( this[2]>>dm;
  pf=new popfile(2 of 2);
  pf[1]<<dm;
  pf[1]>>fid>>len>>rest;
  if 0<=fid
  then inf=new insfile(2 of 2);
       inf[1]<<pf<<fid<<len;
       inf[1]>>
       {^err:
         file=new nlist(2 of 2);
         file[1]<<fid<<len;
         file[1]<<^append<<rest;
         cd=new compressdiskmap(2 of 2);
         cd[1]<<inf;
         cd[1]<<^append<<file;
         cd[1]<<^takeover<<this;
        ^ok:
         cd=new compressdiskmap(2 of 2);
         cd[1]<<inf;
         cd[1]<<^append<<rest;
         cd[1]<<^takeover<<this;
       }
  else pf[1]<<^end;
       rest[1]<<^takeover<<thid;
) // }}}
|
#define $diskmapchecksum \
  2->1:$list(Int)(2 of 1 pure,2); \
  2->1:Int; \
  1->2:Int; \
  $end;
global $diskmapchecksum diskmapchecksum(1 ispure,2);
local ispure service Service(diskmapchecksum (1 of 2) this) // {{{
( this[2]>>dm>>i;
  dm[1]<<^pop;
  dm[1]>>
  {^nil:
    this[2]<<0;
   ^cons:
    dm[1]>>head>>tail;
    dmc=new diskmapchecksum(2 of 2);
    dmc[1]<<tail<<i+1;
    dmc[1]>>r;
    this[2]<<r+i*head;
  }
) // }}}
|
// Process data and print result
local Process($list(String)(2 of 1 pure,2) lines) // {{{
( lines[1]<<^pop;
  lines[1]>>
  {^nil:
    debug("No diskmap!");
   ^cons:
    lines[1]>>line>>ltail;
    ltail[1]<<^end;
    pdm=new parsediskmap(2 of 2);
    pdm[1]<<0<<line;
    cdm=new compressdiskmap(2 of 2);
    cdm[1]<<pdm;
    pl=new printlist(2 of 2);
    pl<<Int;
    pl[1]<<int2string<<cdm;
    //dmc=new diskmapchecksum(2 of 2);
    //dmc[1]<<cdm<<0;
    //dmc[1]>>checksum;
    //c=new console(2 of 2);
    //c[1]<<^str<<"Checksum: "<<^int<<checksum<<^nl<<^end;
  }
) // }}}
// Parse file, handle errors and call Process with parsed structure
local ProcessFile($infile(2 of 1,2) fin) // {{{
( local ProcessFile2($infile(2 of 1,2) fin, $list(String)(2 of 1 pure,2) lines) // {{{
  ( fin[1]<<^Line;
    fin[1]>>
    {^Some:
      fin[1]>>line;
      // Ignore empty lines
      if line&^length<=1
      then ProcessFile2(fin,lines);
      else lines[1]<<^cons<<line;
           ProcessFile2(fin,lines);
     ^None:
      rlines=new revlist(2 of 2);
      rlines<<String;
      rlines[1]<<lines;
      Process(rlines);
    }
  ) // }}}
  lines=new list(2 of 2);
  lines<<String;
  ProcessFile2(fin,lines);
) // }}}
// Open file, handle errors and call ProcessFile with filehandle in case of success
local ProcessFilename(String fname) // {{{
( f=new file(2 of 2);
  f[1]<<^Read<<fname;
  f[1]>>
  {^OK:
    ProcessFile(f);
   ^Error:
    f[1]>>err;
    c=new console(2 of 2);
    c[1]<<^str<<"Unable to open input file: " << ^str << err << ^nl << ^end;
  }
) // }}}
// Actual program
arguments = new args(2 of 2);
arguments[1]<<^arg<<1;
arguments[1]>>
{^none:
  arguments[1]<<^end;
  ProcessFilename("input");
 ^some:
  arguments[1]>>fname;
  arguments[1]<<^end;
  ProcessFilename(fname);
}
